package com.csuxac.core.detection

import com.csuxac.config.ExploitConfig
import com.csuxac.core.models.*
import com.csuxac.util.logging.defaultLogger
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.launch
import kotlin.math.abs
import kotlin.math.max
import kotlin.math.min
import kotlin.math.sqrt

/**
 * ExploitSpecificDetector - Targeted detection for specific cheat techniques
 * 
 * Features:
 * - LiquidBounce specific detection
 * - Wurst bypass detection
 * - Impact exploit detection
 * - Doomsday technique detection
 * - Scaffold and KillAura detection
 */
class ExploitSpecificDetector(
    private val config: ExploitConfig
) {
    private val logger = defaultLogger()
    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.Default)
    
    // Exploit pattern tracking
    private val exploitPatterns = mutableMapOf<String, MutableList<ExploitPattern>>()
    private val techniqueHistory = mutableMapOf<String, MutableList<TechniqueRecord>>()
    
    /**
     * Detect specific exploits in player actions
     */
    suspend fun detectExploit(
        action: PlayerAction,
        session: PlayerSecuritySession
    ): List<Violation> {
        val violations = mutableListOf<Violation>()
        
        try {
            // 1. Fly hack detection
            if (config.flyDetection) {
                val flyViolation = detectFlyHack(action, session)
                if (flyViolation != null) violations.add(flyViolation)
            }
            
            // 2. Phase hack detection
            if (config.phaseDetection) {
                val phaseViolation = detectPhaseHack(action, session)
                if (phaseViolation != null) violations.add(phaseViolation)
            }
            
            // 3. Speed hack detection
            if (config.speedDetection) {
                val speedViolation = detectSpeedHack(action, session)
                if (speedViolation != null) violations.add(speedViolation)
            }
            
            // 4. Reach hack detection
            if (config.reachDetection) {
                val reachViolation = detectReachHack(action, session)
                if (reachViolation != null) violations.add(reachViolation)
            }
            
            // 5. Auto-clicker detection
            if (config.autoClickerDetection) {
                val autoClickerViolation = detectAutoClicker(action, session)
                if (autoClickerViolation != null) violations.add(autoClickerViolation)
            }
            
            // 6. KillAura detection
            if (config.killAuraDetection) {
                val killAuraViolation = detectKillAura(action, session)
                if (killAuraViolation != null) violations.add(killAuraViolation)
            }
            
            // 7. Scaffold detection
            if (config.scaffoldDetection) {
                val scaffoldViolation = detectScaffold(action, session)
                if (scaffoldViolation != null) violations.add(scaffoldViolation)
            }
            
            // 8. NoFall detection
            if (config.noFallDetection) {
                val noFallViolation = detectNoFall(action, session)
                if (noFallViolation != null) violations.add(noFallViolation)
            }
            
            // 9. Timer hack detection
            if (config.timerDetection) {
                val timerViolation = detectTimerHack(action, session)
                if (timerViolation != null) violations.add(timerViolation)
            }
            
            // 10. Velocity bypass detection
            if (config.velocityBypassDetection) {
                val velocityViolation = detectVelocityBypass(action, session)
                if (velocityViolation != null) violations.add(velocityViolation)
            }
            
            // 11. Packet spoofing detection
            if (config.packetSpoofingDetection) {
                val packetViolation = detectPacketSpoofing(action, session)
                if (packetViolation != null) violations.add(packetViolation)
            }
            
            // Record technique usage
            recordTechniqueUsage(action, session)
            
        } catch (e: Exception) {
            logger.error(e) { "Error during exploit detection for player ${action.playerId}" }
        }
        
        return violations
    }
    
    /**
     * Detect LiquidBounce fly bypass
     */
    private fun detectFlyHack(action: PlayerAction, session: PlayerSecuritySession): Violation? {
        if (action.type != ActionType.MOVE) return null
        
        val history = techniqueHistory[session.playerId] ?: return null
        if (history.size < 5) return null
        
        val recentActions = history.takeLast(10)
        val flyActions = recentActions.filter { it.actionType == ActionType.MOVE }
        
        if (flyActions.size < 3) return null
        
        // Check for sustained upward movement
        val yDeltas = flyActions.zipWithNext().map { (prev, next) ->
            next.position.y - prev.position.y
        }
        
        val sustainedUpward = yDeltas.count { it > 0.1 }
        val totalMovements = yDeltas.size
        
        if (sustainedUpward > totalMovements * 0.7) {
            return Violation(
                type = ViolationType.FLY_HACK,
                confidence = 0.9,
                evidence = listOf(
                    Evidence(
                        type = EvidenceType.PATTERN_DETECTION,
                        value = "Sustained upward: $sustainedUpward/$totalMovements",
                        confidence = 0.9,
                        description = "LiquidBounce fly bypass detected"
                    )
                ),
                timestamp = System.currentTimeMillis(),
                playerId = action.playerId
            )
        }
        
        return null
    }
    
    /**
     * Detect phase hack (collision bypass)
     */
    private fun detectPhaseHack(action: PlayerAction, session: PlayerSecuritySession): Violation? {
        if (action.type != ActionType.MOVE) return null
        
        val history = techniqueHistory[session.playerId] ?: return null
        if (history.size < 2) return null
        
        val lastAction = history.last()
        val currentAction = action
        
        // Check for impossible movement through blocks
        val distance = lastAction.position.distanceTo(currentAction.position)
        val timeDelta = currentAction.timestamp - lastAction.timestamp
        
        // If movement is too fast for the time delta, possible phase
        val speed = distance / (timeDelta / 1000.0)
        if (speed > 2.0 && timeDelta < 100) { // 2 blocks per second in less than 100ms
            return Violation(
                type = ViolationType.PHASE_HACK,
                confidence = 0.95,
                evidence = listOf(
                    Evidence(
                        type = EvidenceType.PHYSICS_VIOLATION,
                        value = "Speed: $speed, Time: $timeDelta",
                        confidence = 0.95,
                        description = "Phase hack detected - impossible movement speed"
                    )
                ),
                timestamp = System.currentTimeMillis(),
                playerId = action.playerId
            )
        }
        
        return null
    }
    
    /**
     * Detect speed hack
     */
    private fun detectSpeedHack(action: PlayerAction, session: PlayerSecuritySession): Violation? {
        if (action.type != ActionType.MOVE) return null
        
        val history = techniqueHistory[session.playerId] ?: return null
        if (history.size < 2) return null
        
        val lastAction = history.last()
        val currentAction = action
        
        val distance = lastAction.position.distanceTo(currentAction.position)
        val timeDelta = currentAction.timestamp - lastAction.timestamp
        
        if (timeDelta <= 0) return null
        
        val speed = distance / (timeDelta / 1000.0)
        val maxAllowedSpeed = 0.5 // Maximum allowed speed
        
        if (speed > maxAllowedSpeed) {
            return Violation(
                type = ViolationType.SPEED_HACK,
                confidence = 0.9,
                evidence = listOf(
                    Evidence(
                        type = EvidenceType.PHYSICS_VIOLATION,
                        value = "Speed: $speed, Max allowed: $maxAllowedSpeed",
                        confidence = 0.9,
                        description = "Speed hack detected"
                    )
                ),
                timestamp = System.currentTimeMillis(),
                playerId = action.playerId
            )
        }
        
        return null
    }
    
    /**
     * Detect reach hack
     */
    private fun detectReachHack(action: PlayerAction, session: PlayerSecuritySession): Violation? {
        if (action.type != ActionType.ATTACK) return null
        
        val target = action.target ?: return null
        if (target.type != TargetType.ENTITY) return null
        
        val distance = target.distance ?: return null
        val maxReach = 4.5 // Maximum reach distance
        
        if (distance > maxReach) {
            return Violation(
                type = ViolationType.REACH_HACK,
                confidence = 0.95,
                evidence = listOf(
                    Evidence(
                        type = EvidenceType.PHYSICS_VIOLATION,
                        value = "Distance: $distance, Max reach: $maxReach",
                        confidence = 0.95,
                        description = "Reach hack detected"
                    )
                ),
                timestamp = System.currentTimeMillis(),
                playerId = action.playerId
            )
        }
        
        return null
    }
    
    /**
     * Detect auto-clicker
     */
    private fun detectAutoClicker(action: PlayerAction, session: PlayerSecuritySession): Violation? {
        if (action.type != ActionType.ATTACK) return null
        
        val history = techniqueHistory[session.playerId] ?: return null
        if (history.size < 10) return null
        
        val recentAttacks = history.takeLast(20).filter { it.actionType == ActionType.ATTACK }
        if (recentAttacks.size < 5) return null
        
        // Check for too-regular clicking
        val intervals = recentAttacks.zipWithNext().map { (prev, next) ->
            next.timestamp - prev.timestamp
        }
        
        val avgInterval = intervals.average()
        val variance = intervals.map { (it - avgInterval).pow(2) }.average()
        val stdDev = sqrt(variance)
        
        // If timing is too regular, it's suspicious
        if (stdDev < avgInterval * 0.1 && intervals.size > 5) {
            return Violation(
                type = ViolationType.AUTO_CLICKER,
                confidence = 0.9,
                evidence = listOf(
                    Evidence(
                        type = EvidenceType.TIMING_ANOMALY,
                        value = "Timing std dev: $stdDev, Avg: $avgInterval",
                        confidence = 0.9,
                        description = "Auto-clicker detected - too regular timing"
                    )
                ),
                timestamp = System.currentTimeMillis(),
                playerId = action.playerId
            )
        }
        
        return null
    }
    
    /**
     * Detect KillAura
     */
    private fun detectKillAura(action: PlayerAction, session: PlayerSecuritySession): Violation? {
        if (action.type != ActionType.ATTACK) return null
        
        val history = techniqueHistory[session.playerId] ?: return null
        if (history.size < 15) return null
        
        val recentActions = history.takeLast(30)
        val attacks = recentActions.filter { it.actionType == ActionType.ATTACK }
        
        if (attacks.size < 8) return null
        
        // Check for rapid attacks in different directions
        val attackIntervals = attacks.zipWithNext().map { (prev, next) ->
            next.timestamp - prev.timestamp
        }
        
        val rapidAttacks = attackIntervals.count { it < 150 } // Less than 150ms between attacks
        val totalAttacks = attackIntervals.size
        
        if (rapidAttacks > totalAttacks * 0.7) {
            return Violation(
                type = ViolationType.KILL_AURA,
                confidence = 0.95,
                evidence = listOf(
                    Evidence(
                        type = EvidenceType.PATTERN_DETECTION,
                        value = "Rapid attacks: $rapidAttacks/$totalAttacks",
                        confidence = 0.95,
                        description = "KillAura detected - too many rapid attacks"
                    )
                ),
                timestamp = System.currentTimeMillis(),
                playerId = action.playerId
            )
        }
        
        return null
    }
    
    /**
     * Detect scaffold hack
     */
    private fun detectScaffold(action: PlayerAction, session: PlayerSecuritySession): Violation? {
        if (action.type != ActionType.PLACE_BLOCK) return null
        
        val history = techniqueHistory[session.playerId] ?: return null
        if (history.size < 20) return null
        
        val recentActions = history.takeLast(40)
        val blockPlacements = recentActions.filter { it.actionType == ActionType.PLACE_BLOCK }
        val movements = recentActions.filter { it.actionType == ActionType.MOVE }
        
        if (blockPlacements.size < 3 || movements.size < 5) return null
        
        // Scaffold typically involves placing blocks while moving
        val blockPlacementRate = blockPlacements.size.toDouble() / movements.size
        
        if (blockPlacementRate > 0.4) { // More than 40% block placement rate
            return Violation(
                type = ViolationType.SCAFFOLD_HACK,
                confidence = 0.9,
                evidence = listOf(
                    Evidence(
                        type = EvidenceType.PATTERN_DETECTION,
                        value = "Block placement rate: $blockPlacementRate",
                        confidence = 0.9,
                        description = "Scaffold hack detected - excessive block placement"
                    )
                ),
                timestamp = System.currentTimeMillis(),
                playerId = action.playerId
            )
        }
        
        return null
    }
    
    /**
     * Detect NoFall hack
     */
    private fun detectNoFall(action: PlayerAction, session: PlayerSecuritySession): Violation? {
        if (action.type != ActionType.MOVE) return null
        
        val history = techniqueHistory[session.playerId] ?: return null
        if (history.size < 5) return null
        
        val recentActions = history.takeLast(10)
        val fallActions = recentActions.filter { 
            it.actionType == ActionType.MOVE && 
            it.position.y < recentActions.first().position.y 
        }
        
        if (fallActions.size < 2) return null
        
        // Check for fall distance vs. damage
        val fallDistance = recentActions.first().position.y - action.position.y
        
        if (fallDistance > 4.0) { // Fall distance that should cause damage
            return Violation(
                type = ViolationType.MOVEMENT_HACK,
                confidence = 0.8,
                evidence = listOf(
                    Evidence(
                        type = EvidenceType.PHYSICS_VIOLATION,
                        value = "Fall distance: $fallDistance",
                        confidence = 0.8,
                        description = "NoFall hack detected - no damage from high fall"
                    )
                ),
                timestamp = System.currentTimeMillis(),
                playerId = action.playerId
            )
        }
        
        return null
    }
    
    /**
     * Detect timer hack
     */
    private fun detectTimerHack(action: PlayerAction, session: PlayerSecuritySession): Violation? {
        val history = techniqueHistory[session.playerId] ?: return null
        if (history.size < 10) return null
        
        val recentActions = history.takeLast(20)
        val intervals = recentActions.zipWithNext().map { (prev, next) ->
            next.timestamp - prev.timestamp
        }
        
        // Check for sub-tick actions
        val subTickActions = intervals.count { it < 45 } // Less than 45ms between actions
        val totalActions = intervals.size
        
        if (subTickActions > totalActions * 0.3) { // More than 30% sub-tick actions
            return Violation(
                type = ViolationType.TIMER_HACK,
                confidence = 0.9,
                evidence = listOf(
                    Evidence(
                        type = EvidenceType.TIMING_ANOMALY,
                        value = "Sub-tick actions: $subTickActions/$totalActions",
                        confidence = 0.9,
                        description = "Timer hack detected - too many sub-tick actions"
                    )
                ),
                timestamp = System.currentTimeMillis(),
                playerId = action.playerId
            )
        }
        
        return null
    }
    
    /**
     * Detect velocity bypass
     */
    private fun detectVelocityBypass(action: PlayerAction, session: PlayerSecuritySession): Violation? {
        // This would integrate with the VelocityEnforcer
        // For now, return null as it's handled elsewhere
        return null
    }
    
    /**
     * Detect packet spoofing
     */
    private fun detectPacketSpoofing(action: PlayerAction, session: PlayerSecuritySession): Violation? {
        // This would integrate with the PacketFlowAnalyzer
        // For now, return null as it's handled elsewhere
        return null
    }
    
    /**
     * Record technique usage for pattern analysis
     */
    private fun recordTechniqueUsage(action: PlayerAction, session: PlayerSecuritySession) {
        val history = techniqueHistory.getOrPut(session.playerId) { mutableListOf() }
        
        val record = TechniqueRecord(
            actionType = action.type,
            timestamp = action.timestamp,
            position = action.position,
            target = action.target,
            metadata = action.metadata
        )
        
        history.add(record)
        
        // Keep only recent history
        if (history.size > 1000) {
            history.removeAt(0)
        }
    }
    
    /**
     * Get exploit statistics for player
     */
    fun getExploitStats(playerId: String): ExploitStats? {
        val history = techniqueHistory[playerId] ?: return null
        
        val totalActions = history.size
        val attacks = history.count { it.actionType == ActionType.ATTACK }
        val movements = history.count { it.actionType == ActionType.MOVE }
        val blockPlacements = history.count { it.actionType == ActionType.PLACE_BLOCK }
        
        return ExploitStats(
            playerId = playerId,
            totalActions = totalActions,
            attackCount = attacks,
            movementCount = movements,
            blockPlacementCount = blockPlacements,
            lastUpdate = history.lastOrNull()?.timestamp ?: 0
        )
    }
    
    // Data classes
    private data class ExploitPattern(
        val id: String,
        val name: String,
        val description: String,
        val confidence: Double,
        val riskLevel: RiskLevel
    )
    
    private data class TechniqueRecord(
        val actionType: ActionType,
        val timestamp: Long,
        val position: Vector3D,
        val target: ActionTarget?,
        val metadata: Map<String, Any>
    )
    
    data class ExploitStats(
        val playerId: String,
        val totalActions: Int,
        val attackCount: Int,
        val movementCount: Int,
        val blockPlacementCount: Int,
        val lastUpdate: Long
    )
}